---
layout: post
title: "Course Material: Introduction to Artificial Intelligence"
author: "Chandra Gummaluru"
---

<img src="https://raw.githubusercontent.com/chandra-gummaluru/chandra-gummaluru.github.io/master/media/ai/ai_ico.svg" style="width:150px;height:150px;">
The following material is heavily based on material developed by many individuals for [CSC384 taught at the University of Toronto](https://artsci.calendar.utoronto.ca/course/csc384h1). All typos are my own.

## Introduction
Our goal is to develop algorithms that can optimally make decisions in various situations. We model these situations as games in the game-theoretic sense:

> **Def. Game**: A **game** consists of:
  - $N$ players, indexed $1$ through $N$
  - a set of states, $S$, in which the game could be in
  - - a set of terminal states, $T \subseteq S$ in which the game ends
  - a utility function, $u_i$ for each player $i$, so that $u_i(s)$ is the benefit of $s \in T$ to $i$
  - a set of actions, $A(s)$ from  each state $s \in S$; each action $a \in A(s)$ is an $n$-vector where $a_i$ denotes $i$'s action with $a_i = \emptyset$ to denote no action.
  - optionally, a cost function, $c$, so that $c(a)\_i$ is $i$'s cost of playing $a\_i$.
> Given an $s_0 \in S$, the outcome of a game is called a \textbf{path} from $s_0$; it is a sequence of actions, $\langle a^{(1)}, \dots, a^{(n)}\rangle$, such that $a^{(i)} \in A(s_i)$, $s_i = a^{(i)}(s_{i-1})$ and $s_n \in T$:
> - the utility for $i$ is $u_i(s_n)$.
> - the cost to $i$ is $\sum_{j}c\left(a^{(j)}\right)\_iI\left(a^{(j)}\_i \neq \emptyset\right),$ where $I$ is the indicator function.
> Given some $s_0 \in S$, we want to find the cheapest path to some $s \in T$ that also maximizes our utility.

We develop these definitions in greater detail in this module.

- [Introduction](https://github.com/chandra-gummaluru/chandra-gummaluru.github.io/raw/master/media/ai/slides/csc384s22_slides_intro.pdf)

Designing algorithms for arbitrary games is quite difficult. Thus, in the following modules, we will begin by mmaking some simplifying assumptions. Later, we will relax these assumptions.

## Constraint Satisfaction Problems
In a constraint satisfaction problem, there is only one player and their goal is to reach any terminal state without concern for how they get there. In other words, the cost function is identitcally zero and the utility is the same for all terminal states. We develop some reasonably efficient algorithms to solve these problems.

- [Constraint Satatisfaction Problems](https://github.com/chandra-gummaluru/chandra-gummaluru.github.io/raw/master/media/ai/slides/csc384s22_slides_csps.pdf)

## Search Problems
In a search problem, we still only have one player whose goal is to reach any terminal state. However, the player now seeks the cheapest path. In other words, the utility is still the same for all terminal states, but the cost function is no longer identitcally zero. We develop a few specific but simple search algorithms to address search problems and analyize their properties. Finally, we consider using heuristics to reduce the complexities of the aforementioned algorithms.

- [Formalization](https://github.com/chandra-gummaluru/chandra-gummaluru.github.io/raw/master/media/ai/slides/csc384s22_slides_search1.pdf)
- [Uninformed Search Algorithms](https://github.com/chandra-gummaluru/chandra-gummaluru.github.io/raw/master/media/ai/slides/csc384s22_slides_search2.pdf)
- [Informed Search Algorithms](https://github.com/chandra-gummaluru/chandra-gummaluru.github.io/raw/master/media/ai/slides/csc384s22_slides_search3.pdf)

## Games
We now consider two-player games in which the players take turns. Each player can obtain a different utility for each terminal state, but neither player cares about the path taken. We develop a few specific but simple algorithms to address these types of games.

- [Formalization](https://github.com/chandra-gummaluru/chandra-gummaluru.github.io/raw/master/media/ai/slides/csc384s22_slides_games1.pdf)
- [Monte-Carlo Tree Search](https://github.com/chandra-gummaluru/chandra-gummaluru.github.io/raw/master/media/ai/slides/csc384s22_slides_games2.pdf)

## Uncertainty
We now consider a situation in which a player's actions are not necessarily deterministic. We develop a modelling framework to represent the relationships between various stochastic decisions.

- [Modelling](https://github.com/chandra-gummaluru/chandra-gummaluru.github.io/raw/master/media/ai/slides/csc384s22_slides_uncert1.pdf)
- [Inference](https://github.com/chandra-gummaluru/chandra-gummaluru.github.io/raw/master/media/ai/slides/csc384s22_slides_uncert2.pdf)

## Knowledge
Finally, we consider an application of games. In this module, we develop a modelling framework and algorithm that can draw logical conclusions from a given set of axioms.

- [Representation](https://github.com/chandra-gummaluru/chandra-gummaluru.github.io/raw/master/media/ai/slides/csc384s22_slides_knowledge1.pdf)
- [Reasoning](https://github.com/chandra-gummaluru/chandra-gummaluru.github.io/raw/master/media/ai/slides/csc384s22_slides_knowledge2.pdf)
